//=======================================================================
// RISCV, A Simple As Possible Core
// Watson Huang
// Jan 2, 2018
// 
// Declare all constant for rvcore
//=======================================================================
package rvcommon

import chisel3._
import chisel3.util._

trait rvspec {
    val xlen = 32           //x register bits, SPEC Vol.I Ch2.1
    val xrsz = 32           //x register size, SPEC Vol.I Figure 2.1
    val misa = "I"          //Encoding of Extension, SPEC Vol.II Table 3.2
    val vendorid = 0
    val archid = 0
    val impid = 0x8000      //Anonymous ID
    val hartid = 0
    
    val NOP = "h00000013".U //ADDI x0,x0,0
}

trait rvdef {
    val opbl = 0
    val opbh = 6
    val rdbl = 7
    val rdbh = 11
    val rs1bl = 15
    val rs1bh = 19
    val rs2bl = 20
    val rs2bh = 24
    val shamtsz = 5 //shift amount bit size
}

trait rvalu {
    val X = UInt(0xF, 4) //Use non-exist op for debug
    val ADD = UInt(0, 4) //value as Verilog style: {funct7[5], funct3[2:0]} = 4'b0000
    val SUB = UInt(8, 4) //{funct7[5], funct3[2:0]} = 4'b1000
    val SLL = UInt(1, 4)
    val SLT = UInt(2, 4)
    val SLTU = UInt(3, 4)
    val XOR = UInt(4, 4)
    val SRL = UInt(5, 4)
    val SRA = UInt(0xD, 4) //{funct7[5], funct3[2:0]} = 4'b1101
    val OR = UInt(6, 4)
    val AND = UInt(7, 4)
    val CP1 = UInt(0xA, 4) //Copy RS1
    val CP2 = UInt(0xB, 4) //Copy RS2
}


trait rvinst {
    //LUI/AUIPC instructions, RV32I Base Instruction Set List up to down order
    val LUI     = BitPat("b?????????????????????????0110111")
    val AUIPC   = BitPat("b?????????????????????????0010111")
    //Jump instructions, RV32I Base Instruction Set List up to down order
    val JAL     = BitPat("b?????????????????????????1101111")
    val JALR    = BitPat("b?????????????????000?????1100111")
    //Branch instructions, RV32I Base Instruction Set List up to down order
    val BEQ     = BitPat("b?????????????????000?????1100011")
    val BNE     = BitPat("b?????????????????001?????1100011")
    val BLT     = BitPat("b?????????????????100?????1100011")
    val BGE     = BitPat("b?????????????????101?????1100011")
    val BLTU    = BitPat("b?????????????????110?????1100011")
    val BGEU    = BitPat("b?????????????????111?????1100011")
    //Load/Store instructions, RV32I Base Instruction Set List up to down orde
    val LB      = BitPat("b?????????????????000?????0000011")
    val LH      = BitPat("b?????????????????001?????0000011")
    val LW      = BitPat("b?????????????????010?????0000011")
    val LBU     = BitPat("b?????????????????100?????0000011")
    val LHU     = BitPat("b?????????????????101?????0000011")
    val SB      = BitPat("b?????????????????000?????0100011")
    val SH      = BitPat("b?????????????????001?????0100011")
    val SW      = BitPat("b?????????????????010?????0100011")
    //For Reg-Imm instructions, RV32I Base Instruction Set List up to down order
    val ADDI     = BitPat("b?????????????????000?????0010011")
    val SLTI     = BitPat("b?????????????????010?????0010011")
    val SLTIU    = BitPat("b?????????????????011?????0010011")
    val XORI     = BitPat("b?????????????????100?????0010011")
    val ORI      = BitPat("b?????????????????110?????0010011")
    val ANDI     = BitPat("b?????????????????111?????0010011")
    val SLLI     = BitPat("b0000000??????????001?????0010011")
    val SRLI     = BitPat("b0000000??????????101?????0010011")
    val SRAI     = BitPat("b0100000??????????101?????0010011")
    //For Reg-Reg instructions, RV32I Base Instruction Set List up to down order
    val ADD     = BitPat("b0000000??????????000?????0110011")
    val SUB     = BitPat("b0100000??????????000?????0110011")
    val SLL     = BitPat("b0000000??????????001?????0110011")
    val SLT     = BitPat("b0000000??????????010?????0110011")
    val SLTU    = BitPat("b0000000??????????011?????0110011")
    val XOR     = BitPat("b0000000??????????100?????0110011")
    val SRL     = BitPat("b0000000??????????101?????0110011")
    val SRA     = BitPat("b0100000??????????101?????0110011")
    val OR      = BitPat("b0000000??????????110?????0110011")
    val AND     = BitPat("b0000000??????????111?????0110011")
    //For FENCE instructions, RV32I Base Instruction Set List up to down order
    val FENCE   = BitPat("b0000????????00000000000000001111")
    val FENCE_I = BitPat("b00000000000000000001000000001111")
    //For CSR Read/Write instructions, RV32I Base Instruction Set List up to down order
    val CSRRW   = BitPat("b?????????????????001?????1110011")
    val CSRRS   = BitPat("b?????????????????010?????1110011")
    val CSRRC   = BitPat("b?????????????????011?????1110011")
    val CSRRWI  = BitPat("b?????????????????101?????1110011")
    val CSRRSI  = BitPat("b?????????????????110?????1110011")
    val CSRRCI  = BitPat("b?????????????????111?????1110011")
    //For CSR Privilege  instructions, RV32I Base Instruction Set List up to down order
    //Volumn II, Priv. Spec. Table 6.1, Page68
    val ECALL   = BitPat("b00000000000000000000000001110011")
    val EBREAK  = BitPat("b00000000000100000000000001110011")
    val MRET    = BitPat("b00110000001000000000000001110011")
    val WFI     = BitPat("b00010000010100000000000001110011")
    //For Debug instruction, Debug Spec 0.13, section 4.4.1
    val DRET    = BitPat("b01111011001000000000000001110011") //0x7B200073
}

trait rvpriv {
    val X = UInt(0, 2)
    val U = UInt(0, 2)
    val S = UInt(1, 2)
    val H = UInt(2, 2) //Has been removed at priv. spec. 1.10, should be available after Hypervisor spec. ready
    val M = UInt(3, 2)
}

trait rvrst { //RV Reset
    val PC = "h80000000".U //for FESVR tester
    val MTVEC = "h00000100".U
}

trait rvcause { //Machine Cause Register, Table 3.6
    //Interrupt
    val X = UInt(0xF, 4)
    val mintr_software = UInt(3, 4)
    val mintr_timer = UInt(7, 4)
    val mintr_external = UInt(11, 4)
    //Exception
    val inst_misalign = UInt(0, 4)
    val inst_access = UInt(1, 4)
    val illegal_inst = UInt(2, 4)
    val breakpoint = UInt(3, 4)
    val load_misalign = UInt(4, 4)
    val load_access = UInt(5, 4)
    val store_misalign = UInt(6, 4)
    val store_access = UInt(7, 4)
    val mecall = UInt(11, 4)
}

object rvspec extends rvspec
object rvalu extends rvalu
object rvinst extends rvinst with rvdef
object rvpriv extends rvpriv
object rvrst extends rvrst
object rvcause extends rvcause

package rvdp {
    
    object op2_sel {
        val X = UInt(7,3) //Default
        val R = UInt(0,3) //R-Type, Register
        val I = UInt(1,3) //I-Type, Imm.
        val S = UInt(2,3) //S-Type, Store Inst.
        val B = UInt(3,3) //SB-Type, Branch Inst.
        val U = UInt(4,3) //U-Type, LUI, AUIPC
        val J = UInt(5,3) //UJ-Type, JAL
    }

    object reg_wren {
        val X = UInt(0,1)
        val N = UInt(0,1) //No
        val Y = UInt(1,1) //Yes
    }

    object mem_wren {
        val X = UInt(0,1)
        val N = UInt(0,1) //No
        val Y = UInt(1,1) //Yes
    }

    object mem_en {
        val X = UInt(0,1)
        val N = UInt(0,1) //No
        val Y = UInt(1,1) //Yes
    }

    object wb_sel {
        val X = UInt(0,2)
        val ALU = UInt(0,2)
        val MEM = UInt(1,2)
        val PC4 = UInt(2,2)
        val CSR = UInt(3,2)
    }

    object mem_type {
        val X = UInt(2,3)
        val B = UInt(0,3)
        val H = UInt(1,3)
        val W = UInt(2,3)
        val BU = UInt(4,3)
        val HU = UInt(5,3)
    }

    object pc_sel {
        val X = UInt(0,2)
        val A4 = UInt(0,2) //Add 4
        val BR = UInt(1,2) //Branch
        val JP = UInt(2,2) //Jump JAL/JALR
        val EX = UInt(3,2) //Exception
    }

    object br_sel {
        val X = UInt(7, 3)
        val BEQ = UInt(0, 3)
        val BNE = UInt(1, 3)
        val BLT = UInt(2, 3)
        val BGE = UInt(3, 3)
        val BLTU = UInt(4, 3)
        val BGEU = UInt(5, 3)
    }

    object op1_sel { //Add this support JAL function to decrease an adder
        val X = UInt(0, 2)
        val R = UInt(0, 2) //RS1
        val P = UInt(1, 2) //PC
        val I = UInt(2, 2) //CSR, ZIMM
    }
}